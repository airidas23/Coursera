# Coursera
# Algorithmic Toolbox
# WEEK 1
## Welcome to the first module of Data Structures and Algorithms! 
Here we will provide an overview of where algorithms and data structures are used (hint: everywhere) and walk you through a few sample programming challenges. The programming challenges represent an important (and often the most difficult!) part of this specialization because the only way to fully understand an algorithm is to implement it. Writing correct and efficient programs is hard; please don’t be surprised if they don’t work as you planned—our first programs did not work either! We will help you on your journey through the specialization by showing how to implement your first programming challenges. We will also introduce testing techniques that will help increase your chances of passing assignments on your first attempt. In case your program does not work as intended, we will show how to fix it, even if you don’t yet know which test your implementation is failing on.
Show less
6 videos, 7 readings, 2 practice quizzes
expand
Graded: A plus B
Graded: Maximum Pairwise Product
# WEEK 2
## Introduction
In this module you will learn that programs based on efficient algorithms can solve the same problem billions of times faster than programs based on naïve algorithms. You will learn how to estimate the running time and memory of an algorithm without even implementing it. Armed with this knowledge, you will be able to compare various algorithms, select the most efficient ones, and finally implement them as our programming challenges!
Show less
12 videos, 3 readings
expand
Graded: Logarithms
Graded: Big-O
Graded: Growth rate
Graded: Programming Assignment 1: Introduction
# WEEK 3
# Greedy Algorithms
In this module you will learn about seemingly naïve yet powerful class of algorithms called greedy algorithms. After you will learn the key idea behind the greedy algorithms, you may feel that they represent the algorithmic Swiss army knife that can be applied to solve nearly all programming challenges in this course. But be warned: with a few exceptions that we will cover, this intuitive idea rarely works in practice! For this reason, it is important to prove that a greedy algorithm always produces an optimal solution before using this algorithm. In the end of this module, we will test your intuition and taste for greedy algorithms by offering several programming challenges.
Show less
10 videos, 1 reading
expand
Graded: Greedy Algorithms
Graded: Fractional Knapsack
Graded: Programming Assignment 2: Greedy Algorithms
# WEEK 4
# Divide-and-Conquer
In this module you will learn about a powerful algorithmic technique called Divide and Conquer. Based on this technique, you will see how to search huge databases millions of times faster than using naïve linear search. You will even learn that the standard way to multiply numbers (that you learned in the grade school) is far from the being the fastest! We will then apply the divide-and-conquer technique to design two efficient algorithms (merge sort and quick sort) for sorting huge lists, a problem that finds many applications in practice. Finally, we will show that these two algorithms are optimal, that is, no algorithm can sort faster!
Show less
20 videos, 5 readings
expand
Graded: Linear Search and Binary Search
Graded: Polynomial Multiplication
Graded: Master Theorem
Graded: Sorting
Graded: Quick Sort
Graded: Programming Assignment 3: Divide and Conquer
# WEEK 5
# Dynamic Programming
In this final module of the course you will learn about the powerful algorithmic technique for solving many optimization problems called Dynamic Programming. It turned out that dynamic programming can solve many problems that evade all attempts to solve them using greedy or divide-and-conquer strategy. There are countless applications of dynamic programming in practice: from maximizing the advertisement revenue of a TV station, to search for similar Internet pages, to gene finding (the problem where biologists need to find the minimum number of mutations to transform one gene into another). You will learn how the same idea helps to automatically make spelling corrections and to show the differences between two versions of the same text.
Show less
12 videos, 3 readings
expand
Graded: Change Money
Graded: Edit Distance
Graded: Knapsack
Graded: Maximum Value of an Arithmetic Expression
Graded: Programming Assignment 4: Dynamic Programming
